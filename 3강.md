### *** 배열의 성질
1. O(1)에 k번째 원소를 변경/확인 가능
2. 추가적으로 소모되는 메모리의 양(=overhead)이 거의 없음
3. Cache hit rate가 높음
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

> #### 배열의 시간 복잡도 _ex) 책장에 책을 넣고 뺄 때 생각해보기_ 
- 임의의 원소 추가/제거 => O(N)
- 임의의 위치 원소 변경/확인 , 원소 끝에 추가, 마지막 원소 제거 => O(1)

> 전체를 특정 값으로 초기화 시키는 방법
```c++
/* algorithm 헤더 사용 */
int a[21];
int b[21][21];
fill(a,a+21,0);  // fill(처음 위치,마지막 위치,값)
for(int i=0; i<21; i++)
  fill(b[i],b[i]+21,0);
  
> 벡터 사용법 (하나씩 출력)
```
for(int e:v1)
  cout << e << ' ';
// e에 v1의 원소들이 하나씩 들어감
// 하지만 e는 복사문이라 v1이 변경되어도 영향 x
// int& e:v1 하면 원본 영향 o
```
